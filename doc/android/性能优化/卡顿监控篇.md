## Choreographer 监控
https://blog.csdn.net/maniuT/article/details/131416948

想要监控卡顿或者是监测App的流畅度，就必须通过代码手段来获取FPS或者每帧耗时，并转化成可以衡量应用卡顿程度的指标。而几乎所有的卡顿监控方案都离不开Choreographer这个类。

在应用层就是通过Choreographer来接受VSync信号并执行每一帧的渲染逻辑。

### VSYNC
https://zhuanlan.zhihu.com/p/455886476

在Android 4.1开始，Project Butter被推出，其主要的目的就是解决Android UI流畅性差的问题，Project Butter对Android Display系统进行了重构，引入三个核心元素：VSYNC、Triple Buffer和Choreographer。

系统每16ms会发送一次VSYNC信号，每收到 VSYNC 中断，CPU 会立即准备 Buffer 数据，

## 卡顿

### 卡顿原因
绘制任务太重，绘制一帧内容耗时太长。
主线程太忙了，导致VSync信号来时还没有准备好数据导致丢帧。

### 卡顿监控
方案1：WatchDog，往主线程发消息，然后延迟看该消息是否被处理，从而得出主线程是否卡顿的依据。
方案不优雅

方案2：利用loop循环时的消息分发前后的日志打印（matrix使用了这个）
替换主线程Looper的Printer，监控dispatchMessage的执行时间（大部分主线程的操作最终都会执行到这个dispatchMessage中）。
这种方案在微信上有较大规模使用，总体来说性能不是很差，matrix目前的EvilMethodTracer和AnrTracer就是用这个来实现的。

```
//Looper.java
for (;;) {
  //这里可能会block，Printer无法监控到next里面发生的卡顿
    Message msg = queue.next(); // might block
    
    // This must be in a local variable, in case a UI event sets the logger
    final Printer logging = me.mLogging;
    if (logging != null) {
        logging.println(">>>>> Dispatching to " + msg.target + " " +
                msg.callback + ": " + msg.what);
    }

    msg.target.dispatchMessage(msg);

    if (logging != null) {
        logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
    }
}

public void setMessageLogging(@Nullable Printer printer) {
   mLogging = printer;
}
```
